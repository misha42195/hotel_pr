в файле auth.py для регистрации и аутентификации пользователей 
скопились функции и переменные, которые нужно вынести в отдельный класс
и переносим переменные окружения в конфиг

1) переносим переменные окружения в конфиг
```python
DB_NAME=booking_test
DB_USER=postgres
DB_PASS=asicsasics
DB_HOST=localhost
DB_PORT=5432
JWT_SECRET_KEY="09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
JWY_ALGORITHM="HS256"
ACCESS_TOKEN_EXPIRE_MINUTES=30

```

```python
from datetime import datetime, timedelta, timezone

import jwt

from fastapi import APIRouter, HTTPException, Response
from passlib.context import CryptContext

from config import settings
from repositories.users import UserRepository
from services.auth import AuthService
from src.database import async_session_maker
from src.schemas.users import UserRequestAdd, UserAdd

from datetime import datetime, timezone, timedelta

import jwt
from passlib.context import CryptContext

from config import settings


class AuthService:
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    def create_access_token(self, data: dict) -> str:
        to_encode = data.copy()
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWY_ALGORITHM)
        return encoded_jwt

    def hashed_password(self, password: str) -> str:
        return self.pwd_context.hash(password)

    def verify_password(self, plain_password, hashed_password):
        return self.pwd_context.verify(plain_password, hashed_password)


```

теперь на место вызова функций create_access_token,hashed_password и
verify_password создаем экземпляр класса AuthService().create_access_token(self, data: dict)

Всюлогику работы с авторизацией и аутентификацией вынесли в отдельный класс AuhService