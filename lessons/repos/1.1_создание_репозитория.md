### создание репозиторя 
 
1) создадим в корне проекта директорию repositories, где создадим файл base.py
```python
repositories/base.py
```

base.py в этом файле будет располагаться базовый класс репозитория, от которого будт наследоваться другие классы
```python
class BaseRepository:
    model = None 

    def __init__(self,session):
        self.session = session

    async def get_all(self,*args,**kwargs):

        query = select(self.model)
        result = await self.session.execute(query)
        result = result.scalars().all()
        return result
```
В классе определен атрибут на уровне класса с именем model = None, который примет значение объекта класса таблицы,
для взаимодействия которой и создается этот репозиторий

например:
```python
1) class HotelsRepository(BaseRepository): # наследуемся от базового репозитория 
    model = HotelsOrm # атрибут ссылается на класс ORM таблицы модели, и уже работаем с атриубтами HotelsOrm
    ...               # а именно title и location
```
2) def __init__(self,session):
        self.session = session
 магический метод принимает объект сесси, то есть для каждого объекта экземплраHotelsRepository передается 
уже созданный объект сесии через который отправляется запрос в БД

3) async def get_all(self,*args,**kwargs):

        query = select(self.model)
        result = await self.session.execute(query)
        result = result.scalars().all()
        return result
метод принимает в качестве аргумента любые позиционные и именованные аргументы, которые понадобятся для взаимодействия 
с объектом таблицы ORM 
4) query = select(self.model) select принимает объект модели, с атрибутами которого предстоит взаимодействовать
то есть селект запрос с полями таблицы модели который получаем через ссылку пространства имен 
экземпляра класса HotelsRepository 
5) result = await self.session.execute(query) через ссылку self.session который ссылается на объект 
сесси создаем запрос в БД и получаем результат

ВЫВОД:
Базовый репозитеорий реализет методы, ктоторые классы наследники просто наследуют
Вызов методов происходит через классы наследники, которые наследуют логику от родителя

========================================================================================================================

### если логика метода специфична для подкласса, который наследуется от BaseRepository, то метод переопределяется 
### в подклассе, и при вызове метода вызов останавливается на подклассе, где и находится вызванный метод

Например в базовом классе реализован метод def get_all() который возвращает все объекты
```python
    async def get_all(self,*args,**kwargs):

        query = select(self.model)
        result = await self.session.execute(query)
        result = result.scalars().all()
        return result
```
метод для подкласса реализованный с таким же именем переопределяется и всносит дополнительную логику получения объектов
через фильтрацию по подстроке
```python
async def get_all(self,
                title=None,
                location=None,
                limit=None,
                offset=None):

        query = select(HotelsOrm)
        if title:
            query = query.filter(HotelsOrm.title.ilike(f"%{title}%"))
            print(f"query_title=", query)
        if location:
            query = query.filter(HotelsOrm.location.ilike(f"%{location}%"))
            print(f"query_title=", query)
        query = (
            query
            .limit(limit)  # ограничение на кол-во объектов
            .offset(offset)  # кол-во отображенных объектов на пред.стр
        )
        print(query.compile(engine, compile_kwargs={"literal_binds": True}))
        result = await self.session.execute(query)
        result = result.scalars().all()
        return result
```

таким образом реализуется паттерн репозиторий в его простом проявлении

