### Паттерн DattaMapper всегда так или иначе связан с паттерном Repository
DattaMapper представляет собой паттерн, который отделяет бизнес логику от логики взаимодействия с Бд
Объекты в бизнес части, то есть в нашем приложении могут иметь разные типы, то есть можем реализовать любого
вида типы объектов, но в БД типы ограниченное кол-во типов. Что бы не взаимодействовать с объектами ORM мы должны 
привести их к общему тип через паттерн DataMapping, и провести валидацию как сохраняемых объектов в БД,
так и получаемых данных из базы

при получении данных при запросе мы указываем hotal_data: BaseModel, учитывая что наши схемы наследуются от 
BaseModel, значит все атриубты проходят валидацию от родительского класса
Немного поменяем схему на добавление HotelAdd и создадим новую схему Hotel, которая наследуется от HotelAdd

```python

class HotelAdd(BaseModel):
    title: str
    location: str

class Hotel(HotelAdd): # наследуемся от HotelAdd и получаем два дополнительных атрибута title и location
    id: int
```

в базовом классе BaseRepository определяем атрибут, который будет иметь тип BaseModel 
по умолчанию со значением None, а в подклассах репозиториев будет ссылатся на определенную 
для подкласса схему schema : BaseMmodel = None

```python
class BaseRepository:
    model = None # model = HotelOrm
    schema: BaseModel = None # schema = Hotel 
    def __init__(self,session):
        self.session = session
```
во всех методах, которые возвращают объект ORM модели-экземпляр объекта 
HotelOrm производим валидацию, то есть приводим к типу схемы Hotel

проходимся по коллекции объектов из result.scalars().all() в цикле и каждый объект приводим к типу схемы
что бы доставать атриубуты из объекта HotelsOrm указываем параметр по умолчанию from_attributes=True
```python
[self.schema.model_validate(hotel,from_attributes=True) for hotel in result.scalars().all()]
```

в итоге метод возвращает список из pydantic схемы, а не объекты HotelOrm