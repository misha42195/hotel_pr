Необходимо получить удобства в ручке при получении конкретного номера
Для этого необходимо создать новый метод в репозитории RoomsRepository,
который подгрузит удобства через relationship, и вызывать этот метод внутри ручки

для получения номера должны передать параметров hotel_id,room_id
а также объект db

```python

class RoomsOrm(Base):
    __tablename__ = "rooms"
    __table_args__ = {'extend_existing': True}

    id: Mapped[int] = mapped_column(primary_key=True)
    hotel_id: Mapped[int] = mapped_column(ForeignKey("hotels.id"))
    title: Mapped[int] = mapped_column(String)
    description: Mapped[str | None]
    price: Mapped[int]
    quantity: Mapped[int]

    facilities: Mapped[list["FacilitiesOrm"]] = relationship(
        back_populates="rooms",
        secondary="rooms_facilities",

    )

```

```python

class FacilitiesOrm(Base):
    __tablename__ = "facilities"

    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(100))

    rooms: Mapped[list["RoomsOrm"]] = relationship(
        back_populates="facilities",
        secondary="rooms_facilities",
    )


class RoomsFacilitiesORM(Base):
    __tablename__ = "rooms_facilities"
    id: Mapped[int] = mapped_column(primary_key=True)

    room_id: Mapped[int] = mapped_column(ForeignKey("rooms.id"))
    facility_id: Mapped[int] = mapped_column(ForeignKey("facilities.id"))

```

```python
@router.get("/{hotel_id}/rooms/{room_id}")
async def get_room(hotel_id: int, room_id: int, db: DBDep):
    return await db.rooms.get_one_or_none(id=room_id, hotel_id=hotel_id)
```

```python
    async def get_one_or_none(self, **filter_by):


    query = (
        select(self.model)
        .options(selectinload(self.model.facilities))
        .filter_by(**filter_by)
    )
result = await self.session.execute(query)
obj = result.scalars().one_or_none()
if obj is None:
    return None
return RoomWitchRels.model_validate(obj, from_attributes=True)
```
